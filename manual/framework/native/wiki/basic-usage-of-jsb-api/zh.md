# JSB API 基本用法

`注意`：基于Cocos2D-X 3.0 alpha0版本新建Cocos2d-x项目，你会找到一个“Classes/AppDelegate.cpp”文件。该文件就是游戏启动的地方。所有的初始化工作都会在“applicationDidFinishLaunching()”中完成。```
Director *director = Director::getInstance();director->setOpenGLView(EGLView::getInstance());…ScriptingCore* sc = ScriptingCore::getInstance();sc->addRegisterCallback(register_all_cocos2dx);…sc->start();ScriptEngineProtocol *engine = ScriptingCore::getInstance();ScriptEngineManager::getInstance()->setScriptEngine(engine);// 1.ScriptingCore::getInstance()->runScript("main.js");```
1)用C++进行一些初始化工作之后，就要开始用到JSB了。你可以任意修改“main.js”名称，所有的JSB代码都从这个文件开始。所以所有准备工作均在“main.js”文件中进行。首先创建一个层。“MyLayer”在“myApp.js”中实现。```
// 2.var MyLayer = cc.Layer.extend({    ...// 3.    ctor:function() {        this._super();        cc.associateWithNative( this, cc.Layer );    },// 4.    init:function () {        this._super();       …        var closeItem = cc.MenuItemImage.create(            "res/CloseNormal.png",            "res/CloseSelected.png",            function () {                cc.log("close button was clicked.");            },this);        var menu = cc.Menu.create(closeItem);        return true;    }});```
2)“MyLayer = cc.Layer.extend();”是JSB创建层（layer）的一种方法，由“CCLayer”继承而来。这种对象继承方式来自于John Resig的Java继承。层是组成场景的根本元素。所以一个层实例应该在场景中创建。3)“ctor()”通过JSB来实现的构造器，当你新建“MyLayer”时便会被调用。如果想要覆盖“ctor()”，不要忘了调用“this._super()”。JSB方法会调用超级类的“ctor()”。“ ctor:function(){}”是创建函数的JS方法，跟C++方法不同。如果要覆盖某个函数的超级类，记得在该函数中调用“this._super()”。4)如果你想要覆盖“init()”，调用“this._super()”——JSB方法会调用超级类的“init()”。如果想用JSB方法创建菜单项（MenuItem），像“cc.MenuItemImage.create(p1, p2, CallFunc, this)”一样创建函数，在C++中类似于“MenuItemImage::create(p1, p2, CC_CALLBACK(Mycalss::callback, this))”方法。实现一个层之后，我们还需要场景来控制这个层。“MyScene”也在“myApp.js”中实现。```
var MyScene = cc.Scene.extend({    ctor:function() {     this._super();     ...    },     // 5.    onEnter:function () {        this._super();        var layer = new MyLayer();        this.addChild(layer);        layer.init();    }});```
5)我们还需要覆盖“ctor()”，在“onEnter()”中新建一个“MyLayer”对象。在“MyScene”对象运行时，“onEnter()”会被调用，然后层便会被动态地创建。现在运行场景。取出“main.js”文件。

```// 6.require("jsb.js");var appFiles = [    'src/resource.js',    'src/myApp.js'];...for( var i=0; i < appFiles.length; i++) {    require( appFiles[i] );}var director = cc.Director.getInstance();...// 7.var myScene = new MyScene();director.runWithScene(myScene);```
6)你可能对C++中依靠其他文件的“#include”方法很熟悉，但是当JS文件调用其他JS文件中的函数中，你要用“reuqire(“”)”。这个函数会告诉引擎动态载入所有需要的JS文件。
7)使用关键字“new”和“ClassName()”创建游戏的第一个场景，在“myApp.js”中实现。这个场景继承自“cc.Scene”，所以“myScene”是一个autorelease object（自动释放对象）。你可能对C++中创建场景的方法很熟悉如auto scene = HelloWorld::createScene();但这里有点不同。
Cocos2D-X 3.0版本以前，如果你熟悉C++方法，可能会习惯使用CCDirector、CCScene、CCLayer以及CCSprite等等。但现在Cocos2D-X 3.0移除了C++类的CC前缀，单元素集使用“getInstance()”而不是“sharedDirector()”等。从2.0版本至3.0版本，我们在JSB中还是用的CC.前缀。这里是C++和JSB中使用Cocos2D-X API接口的一些样例：
|C++	|JSB||-------|----||Director::getInstance()|	cc.Director.getInstance()||Menu::create(m1, m2, NULL)	|cc.Menu.create(m1, m2)||Sequence::create(a1, a2, NULL)	|cc.Sequence.create(a1, a2)||Point()|	cc.p()||MenuItemLabel::create(label, CC_CALLBACK_1(MyClass::callBcak, this))|	cc.MenuItemLabel.create(label, function(){do_something}, this)||etc...	||